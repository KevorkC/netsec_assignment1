#!/usr/bin/env python

import base64
import json
import random
import sys

import requests

p = lambda *args, **kvargs: print(*args, **kvargs)

if __name__ == "__main__":
    argc = len(sys.argv)
    args = sys.argv[1:]

    if argc != 2:
        p(
            f"""usage: {sys.argv[0]} <url: str>""",
            file=sys.stderr,
        )
        sys.exit(1)

    url = args[0]

    # Handy URL requester
    http_get = lambda route, *args, **kvargs: requests.get(f"{url}/{route}",*args, **kvargs, verify=False)

    # Get public RSA key from server
    resp                    =  http_get('pk') # Public key
    assert resp.status_code == 200
    resp_as_json            =  resp.json()
    N                       =  int(resp_as_json["N"])   # Modulus
    e                       =  int(resp_as_json["e"])   # Public exponent

    hexify             = lambda s: s.encode('utf-8').hex() # Convert string to hex
    hex_but_without_0x = lambda n: hex(n)[2:]              # Convert int to hex without 0x prefix

    # Found by looking in the server code for this assignment
    forged_msg_to_sign: str         = 'You got a 12 because you are an excellent student! :)'
    forged_msg_to_sign_hex: int     = hexify(forged_msg_to_sign)

    # abuse the malleability property of textbook RSA
    while True:
        r: int                  = random.randint(0, N - 1) # Needs to be a coprime of N (N being the modulus)
        m: int                  = int.from_bytes(forged_msg_to_sign.encode(), byteorder = 'big') # Convert to integer message representative
        r_encrypted: int        = pow(r,e, N) # Encrypt r with the public key
        m_composite: int        = (m * r_encrypted) % N
        m_composite_as_hex: str = hex_but_without_0x(m_composite)

        route                     =  f'sign_random_document_for_students/{m_composite_as_hex}/'
        resp                      =  http_get(route)
        # Sometimes the server returns an error becasue it finds one of 
        # ['grade', '12', 'twelve', 'tolv'] in the m_composite. This is up 
        # to chance, since r is randomly generated.
        if resp.status_code != 200:
            continue
        payload                   =  resp.json()
        blinded_signature_in_hex: str     =  payload['signature']
        blinded_signature_in_bytes: bytes =  bytes.fromhex(blinded_signature_in_hex)
        blinded_signature_as_large_int    =  int.from_bytes(blinded_signature_in_bytes, byteorder = 'big')
        break

    # Compute the modular multiplicative inverse ... TODO
    # Signature that signs our forged msg
    extracted_signature: int        = blinded_signature_as_large_int * pow(r, -1, N) % N
    extracted_signature_hex: str    = hex_but_without_0x(extracted_signature)

    grade = {   
        'msg': forged_msg_to_sign_hex,
        'signature': extracted_signature_hex,
    }

    # Server does: cookie grade |> base64 decode |> json desirialize
    # Thus the client does: grade |> json serialize |> base64 encode |> cookie
    grade_as_json_str: str                = json.dumps(grade)
    grade_as_bytes: bytes                 = grade_as_json_str.encode()
    grade_encoded_with_base64: bytes      = base64.b64encode(grade_as_bytes, altchars = b'-_') # The same option for altchars is used in the server
    grade_encoded_with_base64_as_str: str = grade_encoded_with_base64.decode()


    resp = http_get('grade/', cookies={'grade': grade_encoded_with_base64_as_str})
    assert resp.status_code == 200

    p(resp.text.removeprefix("<p>").removesuffix("</p>"))

    # As we've gotten a confirmation that we got a "twelve" grade, we should now be able to get a quote
    resp = http_get('quote/', cookies={'grade': grade_encoded_with_base64_as_str}) # The server expects the cookie to be called grade
    assert resp.status_code == 200

    p(resp.text.removeprefix("<quote>").removesuffix("</quote>"))