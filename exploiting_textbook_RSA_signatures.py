#!/usr/bin/env python

import sys
import random
from pprint import pp
import base64

import pretty_errors # when the script crashes, this will print the stack trace in a prettier way :)
import json

import requests

p = lambda *args, **kvargs: print(*args, **kvargs)
pt = lambda *args, **kvargs: p([arg for arg in args], [type(arg) for arg in args], **kvargs)

# OBJECTIVE: forge signature of request to grading server so that
# it accepts a message saying we got 12.

# without the forgery, it is only possible to get a grade between [-3, 00, 02, 4, 7, 10]
# the attack abbuses a vulnerability in plain RSA (without padding, I think?)
# if the attacker sends a valid signature, then the server will reply with whatever 
# message give to it, in our case this would be the message saying we got a 12.

# THIS is the code the server uses to decome and read our sent grade cookie
# # decode the base 64 encoded cookie from the request
# c = cookie_to_json(request.cookies.get('grade'))
# # deserialize the JSON object which we expect in the cookie
# j = json.loads(c)
# # decode the hexadecimal encoded byte strings
# msg = bytes.fromhex(j['msg'])
# signature = bytes.fromhex(j['signature'])

# cookies = {
#    'grade': {
#        'msg': "our desired grade",
#        'signature': "the valid signature"
#    }
# }

# use http route /sign_random_document_for_students/<data>/
# it will get rejected if it contains anything that looks like a grade i.e. 
# ['grade', '12', 'twelve', 'tolv']    

# The data is expected in hexadecimal encoding as part of the URL.  E.g.,
# `/sign_random_document_for_students/42424242/` returns a signature of the
# string 'BBBB'.

# message signature is computed as:
# m is the message
# if not 0 <= m < N:
#    ERROR
# s = pow(m, d, N)
# signature = s.to_bytes(math.ceil(N.bit_length() / 8), 'big')
# return signature

if __name__ == "__main__":
    argc = len(sys.argv)
    args = sys.argv[1:]

    if argc != 2:
        print(
            f"""
usage: {sys.argv[0]} <url: str>
        """,
            file=sys.stderr,
        )
        sys.exit(1)

    url = args[0]

    http_get = lambda route, *args, **kvargs: requests.get(f"{url}/{route}",*args, **kvargs, verify=False)

    # get public RSA key from server
    resp                    =  http_get('pk')
    assert resp.status_code == 200
    resp_as_json            =  resp.json()
    N                       =  int(resp_as_json["N"])
    e                       =  int(resp_as_json["e"])

    hexify             = lambda s: s.encode('utf-8').hex()
    hex_but_without_0x = lambda n: hex(n)[2:]

    # found by looking in the server code for this assignment
    forged_msg: str   = 'You got a 12 because you are an excellent student! :)'
    forged_msg_in_hex = hexify(forged_msg)

    # abuse the malleability property of textbook RSA
    r: int                  = random.randint(0, N - 1)
    m: int                  = int.from_bytes(forged_msg.encode(), byteorder = 'big')
    r_encrypted: int        = pow(r,e, N) # encrypt r with the public key
    m_composite: int        = (m * r_encrypted) % N
    m_composite_as_hex: str = hex_but_without_0x(m_composite)

    route                     =  f'sign_random_document_for_students/{m_composite_as_hex}/'
    resp                      =  http_get(route)
    assert resp.status_code   == 200
    payload                   =  resp.json()
    signature_in_hex: str     =  payload['signature']
    signature_in_bytes: bytes =  bytes.fromhex(signature_in_hex)
    signature_as_large_int    =  int.from_bytes(signature_in_bytes, byteorder = 'big')
    pp({'signature_as_large_int': signature_as_large_int})

    # compute the modular multiplicative inverse ... TODO
    s: int        = signature_as_large_int * pow(r, -1, N) % N
    s_as_hex: str = hex_but_without_0x(s)
    # s_as_hex = s_as_hex + '9'

    grade = {
        'msg': forged_msg_in_hex,
        'signature': s_as_hex,
    }

    # # client does: grade |> json serialize |> base64 encode |> cookie
    # # server does: cookie grade |> base64 decode |> json desirialize
    grade_as_json_str: str                = json.dumps(grade)
    grade_as_bytes: bytes                 = grade_as_json_str.encode()
    b64encode                             = lambda bs: base64.b64encode(bs, altchars = b'-_')
    grade_encoded_with_base64: bytes      = b64encode(grade_as_bytes)
    grade_encoded_with_base64_as_str: str = grade_encoded_with_base64.decode()

    resp = http_get('quote/', cookies={'grade': grade_encoded_with_base64_as_str})
    assert resp.status_code == 200

    # if the response contains:
    # <redacted> for testing purposes
    # the the attack was succesful on the localhost version of the server.
    p(resp.text)

    resp = http_get('grade/', cookies={'grade': grade_encoded_with_base64_as_str})
    assert resp.status_code == 200

    p(resp.text)

